% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NMF-class.R, R/transforms.R, R/heatmaps.R,
%   R/fixed-terms.R, R/NMFfit-class.R, R/NMFSet-class.R, R/NMFStrategy-class.R,
%   R/NMFplots.R, R/registry-algorithms.R, R/extractFeatures.R, R/nmf.R,
%   R/rnmf.R
\docType{class}
\name{NMF-class}
\alias{NMF-class}
\alias{fitted,NMF-method}
\alias{basis,NMF-method}
\alias{.basis,NMF-method}
\alias{basis<-,NMF-method}
\alias{.basis<-,NMF,mMatrix-method}
\alias{coef,NMF-method}
\alias{.coef,NMF-method}
\alias{coef<-,NMF-method}
\alias{.coef<-,NMF,mMatrix-method}
\alias{coefficients,NMF-method}
\alias{scoef,NMF-method}
\alias{scale.NMF}
\alias{show,NMF-method}
\alias{misc}
\alias{$,NMF-method}
\alias{$<-,NMF-method}
\alias{.DollarNames.NMF}
\alias{rmatrix,NMF-method}
\alias{sparseness,NMF-method}
\alias{predict,NMF-method}
\alias{basiscor,NMF,matrix-method}
\alias{basiscor,matrix,NMF-method}
\alias{basiscor,NMF,NMF-method}
\alias{basiscor,NMF,missing-method}
\alias{profcor,NMF,matrix-method}
\alias{profcor,matrix,NMF-method}
\alias{profcor,NMF,NMF-method}
\alias{profcor,NMF,missing-method}
\alias{connectivity,NMF-method}
\alias{deviance,NMF-method}
\alias{anyNA.NMF}
\alias{rposneg,NMF-method}
\alias{t.NMF}
\alias{metaHeatmap,NMF-method}
\alias{basismap,NMF-method}
\alias{coefmap,NMF-method}
\alias{c,NMF-method}
\alias{ibterms,NMF-method}
\alias{icterms,NMF-method}
\alias{fit<-,NMFfit,NMF-method}
\alias{nmf.equal,NMFfit,NMF-method}
\alias{nmf.equal,NMF,NMFfit-method}
\alias{nrun,NMF-method}
\alias{consensus,NMF-method}
\alias{consensushc,NMF-method}
\alias{nmf.equal,NMFfitX,NMF-method}
\alias{nmf.equal,NMF,NMFfitX-method}
\alias{consensusmap,NMF-method}
\alias{run,NMFStrategy,mMatrix,NMF-method}
\alias{silhouette.NMF}
\alias{canFit,NMFStrategy,NMF-method}
\alias{featureScore,NMF-method}
\alias{extractFeatures,NMF-method}
\alias{nmf,mMatrix,NMF,ANY-method}
\alias{seed,mMatrix,NMF,NMFSeed-method}
\alias{rnmf,NMF,numeric-method}
\alias{rnmf,NMF,missing-method}
\title{Generic Interface for Nonnegative Matrix Factorisation Models}
\usage{
\S4method{fitted}{NMF}(object, ...)

\S4method{basis}{NMF}(object, ..., all = TRUE)

\S4method{.basis}{NMF}(object, ...)

\S4method{basis}{NMF}(object, ..., use.dimnames = TRUE) <- value

\S4method{.basis}{NMF,mMatrix}(object) <- value

\S4method{coef}{NMF}(object, ..., all = TRUE)

\S4method{.coef}{NMF}(object, ...)

\S4method{coef}{NMF}(object, ..., use.dimnames = TRUE) <- value

\S4method{.coef}{NMF,mMatrix}(object) <- value

\S4method{coefficients}{NMF}(object, ..., all = TRUE)

\S4method{scoef}{NMF}(object, scale = 1)

\method{scale}{NMF}(x, center = c("basis", "coef"), scale = 1)

\S4method{show}{NMF}(object)

misc(object, ...)

\S4method{$}{NMF}(x, name)

\S4method{$}{NMF}(x, name) <- value

\method{.DollarNames}{NMF}(x, pattern = "")

\S4method{rmatrix}{NMF}(x, ...)

\S4method{sparseness}{NMF}(x)

\S4method{predict}{NMF}(
  object,
  what = c("columns", "rows", "samples", "features"),
  prob = FALSE,
  dmatrix = FALSE
)

\S4method{basiscor}{NMF,matrix}(x, y, ...)

\S4method{basiscor}{matrix,NMF}(x, y, ...)

\S4method{basiscor}{NMF,NMF}(x, y, ...)

\S4method{basiscor}{NMF,missing}(x, y, ...)

\S4method{profcor}{NMF,matrix}(x, y, ...)

\S4method{profcor}{matrix,NMF}(x, y, ...)

\S4method{profcor}{NMF,NMF}(x, y, ...)

\S4method{profcor}{NMF,missing}(x, y, ...)

\S4method{connectivity}{NMF}(object, no.attrib = FALSE)

\S4method{deviance}{NMF}(object, y, method = c("", "KL", "euclidean"), ...)

\method{anyNA}{NMF}(x, recursive = FALSE)

\S4method{rposneg}{NMF}(object, ...)

\method{t}{NMF}(x)

\S4method{metaHeatmap}{NMF}(object, ...)

\S4method{basismap}{NMF}(
  object,
  color = "YlOrRd:50",
  scale = "r1",
  Rowv = TRUE,
  Colv = NA,
  subsetRow = FALSE,
  annRow = NA,
  annCol = NA,
  tracks = "basis",
  main = "Basis components",
  info = FALSE,
  ...
)

\S4method{coefmap}{NMF}(
  object,
  color = "YlOrRd:50",
  scale = "c1",
  Rowv = NA,
  Colv = TRUE,
  annRow = NA,
  annCol = NA,
  tracks = "basis",
  main = "Mixture coefficients",
  info = FALSE,
  ...
)

\S4method{c}{NMF}(x, ..., margin = 3L, recursive = FALSE)

\S4method{ibterms}{NMF}(object, ...)

\S4method{icterms}{NMF}(object, ...)

\S4method{fit}{NMFfit,NMF}(object) <- value

\S4method{nmf.equal}{NMFfit,NMF}(x, y, ...)

\S4method{nmf.equal}{NMF,NMFfit}(x, y, ...)

\S4method{nrun}{NMF}(object)

\S4method{consensus}{NMF}(object, ...)

\S4method{consensushc}{NMF}(object, ...)

\S4method{nmf.equal}{NMFfitX,NMF}(x, y, ...)

\S4method{nmf.equal}{NMF,NMFfitX}(x, y, ...)

\S4method{consensusmap}{NMF}(object, ...)

\S4method{run}{NMFStrategy,mMatrix,NMF}(object, y, x, ...)

\method{silhouette}{NMF}(x, what = NULL, order = NULL, ...)

\S4method{canFit}{NMFStrategy,NMF}(x, y, ...)

\S4method{featureScore}{NMF}(object, ...)

\S4method{extractFeatures}{NMF}(object, ...)

\S4method{nmf}{mMatrix,NMF,ANY}(x, rank, method, seed, ...)

\S4method{seed}{mMatrix,NMF,NMFSeed}(x, model, method, rng, ...)

\S4method{rnmf}{NMF,numeric}(x, target, ncol = NULL, keep.names = TRUE, dist = runif)

\S4method{rnmf}{NMF,missing}(x, target, ...)
}
\arguments{
\item{object}{an object that inherit from \linkS4class{NMF}.}

\item{...}{extra arguments not used.}

\item{all}{a logical that indicates whether the complete matrix factor
should be returned (\code{TRUE}) or only the non-fixed part.
This is relevant only for formula-based NMF models that include fixed basis or
coefficient terms.}

\item{use.dimnames}{logical that indicates if the object's dim names should be
set using those from the new value, or left unchanged -- after truncating
them to fit new dimensions if necessary.
This is useful to only set the entries of a factor.}

\item{scale}{scaling coefficient applied to \eqn{D}, i.e. the value of \eqn{\alpha}{alpha},
or, if \code{center='coef'}, the value of \eqn{1/\alpha}{1/alpha} (see section \emph{Details}).}

\item{x, y}{objects of that generally inherit from \linkS4class{NMF}.
Depending on the method, either or both are \code{NMFfitX} objects.}

\item{center}{either a numeric normalising vector \eqn{\delta}{delta}, or either
\code{'basis'} or \code{'coef'}, which respectively correspond to using the
column sums of the basis matrix or the inverse of the row sums of the
coefficient matrix as a normalising vector.
If numeric, \code{center} should be a single value or a vector of length the
rank of the NMF model, i.e. the number of columns in the basis matrix.}

\item{what}{defines the type of clustering the computed silhouettes are
meant to assess: \code{'samples'} for the clustering of samples
(i.e. the columns of the target matrix),
\code{'features'} for the clustering of features (i.e. the rows of the
target matrix), and \code{'chc'} for the consensus clustering of samples as
defined by hierarchical clustering dendrogram, \code{'consensus'} for the
consensus clustering of samples, with clustered ordered as in the
\strong{default} hierarchical clustering used by
\code{\link{consensusmap}} when plotting the heatmap of the consensus matrix
(for multi-run NMF fits).
That is \code{dist = 1 - consensus(x)}, average linkage and reordering based
on row means.}

\item{prob}{logical that indicates if the relative contributions of/to the dominant
basis component should be computed and returned. See \emph{Details}.}

\item{dmatrix}{logical that indicates if a dissimiliarity matrix should be
attached to the result.
This is notably used internally when computing NMF clustering silhouettes.}

\item{y}{a matrix compatible with the NMF model \code{object}, i.e. \code{y}
must have the same dimension as \code{fitted(object)}.}

\item{no.attrib}{a logical that indicates if attributes containing information
about the NMF model should be attached to the result (\code{TRUE}) or not
(\code{FALSE}).}

\item{method}{a character string or a function with signature
\code{(x="NMF", y="matrix", ...)} that implements a distance measure between
an NMF model \code{x} and a target matrix \code{y}, i.e. an objective function
to use to compute the deviance.
In \code{deviance}, it is passed to \code{nmfDistance} to get the function
that effectively computes the deviance.}

\item{color}{colour specification for the heatmap. Default to palette
'-RdYlBu2:100', i.e. reversed palette 'RdYlBu2' (a slight modification of
RColorBrewer's palette 'RdYlBu') with 100 colors.
Possible values are:
\itemize{
\item a character/integer vector of length greater than 1 that is directly used
and assumed to contain valid R color specifications.
\item a single color/integer (between 0 and 8)/other numeric value
that gives the dominant colors. Numeric values are converted into a pallete
by \code{rev(sequential_hcl(2, h = x, l = c(50, 95)))}. Other values are
concatenated with the grey colour '#F1F1F1'.
\item RColorBrewer palette names (see \code{\link[RColorBrewer]{display.brewer.all}})
\item \code{viridis} palette names: 'viridis', 'inferno', 'plasma', 'magma';
\item one of 'RdYlBu2', 'rainbow', 'heat', 'topo', 'terrain', 'cm'.
}
When the colour palette is specified with a single value, and is negative or
preceded a minus ('-'), the reversed palette is used.
The number of breaks can also be specified after a colon (':'). For example,
the default colour palette is specified as '-RdYlBu2:100'.}

\item{Rowv}{clustering specification(s) for the rows. It allows to specify
the distance/clustering/ordering/display parameters to be used for the
\emph{rows only}.

See section \emph{Row/column ordering and display} for details on all supported values.}

\item{Colv}{clustering specification(s) for the columns. It accepts the same
values as argument \code{Rowv} (modulo the expected length for vector specifications),
and allow specifying the distance/clustering/ordering/display parameters to
be used for the \emph{columns only}.

\code{Colv} may also be set to \code{"Rowv"}, in which case the dendrogram
or ordering specifications applied to the rows are also applied to the
columns. Note that this is allowed only for square matrices,
and that the row ordering is in this case by default reversed
(\code{revC=TRUE}) to obtain the diagonal in the standard way
(from top-left to bottom-right).

See section \emph{Row/column ordering and display} for details on all supported values.}

\item{subsetRow}{Argument that specifies how to filter the rows that
will appear in the heatmap.
When \code{FALSE} (default), all rows are used.
Besides the values supported by argument \code{subsetRow} of
\code{\link{aheatmap}}, other possible values are:

\itemize{
\item \code{TRUE}: only the rows that are basis-specific are used.
The default selection method is from Kim and Park (2007).
This is equivalent to \code{subsetRow='kim'}.

\item a single \code{character} string or numeric value that specifies
the method to use to select the basis-specific rows, that should appear in the
heatmap (cf. argument \code{method} for function \code{\link{extractFeatures}}).

Note \code{\link{extractFeatures}} is called with argument \code{nodups=TRUE},
so that features that are selected for multiple components only appear once.
}}

\item{annRow}{specifications of row annotation tracks displayed as coloured
columns on the left of the heatmaps. The annotation tracks are drawn from
left to right. The same conversion, renaming and colouring rules as for argument
\code{annCol} apply.}

\item{annCol}{specifications of column annotation tracks displayed as coloured
rows on top of the heatmaps. The annotation tracks are drawn from bottom to top.
A single annotation track can be specified as a single vector; multiple tracks
are specified as a list, a data frame, or an
\code{\link[Biobase:ExpressionSet-class]{ExpressionSet}} object, in
which case the phenotypic data is used (\code{pData(eset)}).
Character or integer vectors are converted and displayed as factors.
Unnamed tracks are internally renamed into \code{Xi}, with i being incremented for
each unamed track, across both column and row annotation tracks.
For each track, if no corresponding colour is specified in argument
\code{annColors}, a palette or a ramp is automatically computed and named
after the track's name.}

\item{tracks}{Special additional annotation tracks to highlight associations between
basis components and sample clusters:
\describe{
\item{basis}{matches each row (resp. column) to the most contributing basis component
in \code{basismap} (resp. \code{coefmap}).
In \code{basismap} (resp. \code{coefmap}), adding a track \code{':basis'} to
\code{annCol} (resp. \code{annRow}) makes the column (resp. row) corresponding to
the component being also highlited using the mathcing colours.}
}}

\item{main}{Main title as a character string or a grob.}

\item{info}{if \code{TRUE} then the name of the algorithm that fitted the NMF
model is displayed at the bottom of the plot, if available.
Other wise it is passed as is to \code{aheatmap}.}

\item{margin}{integer that indicates the margin along which to concatenate
(only used when \code{..1} is a matrix):
\describe{
\item{1L}{}
\item{2L}{}
\item{3L}{}
\item{4L}{}
}
If missing the margin is heuristically determined by looking at common
dimensions between the objects.}

\item{order}{integer indexing vector that can be used to force the silhouette
order.}

\item{rng}{rng setting to use.
If not missing the RNG settings are set and restored on exit using
\code{\link{setRNG}}.

All arguments in \code{...} are passed to teh seeding strategy.}

\item{ncol}{single numeric value that specifies the number of columns of the
coefficient matrix. Only used when \code{target} is a single numeric value.}

\item{keep.names}{a logical that indicates if the dimension names of the
original NMF object \code{x} should be conserved (\code{TRUE}) or discarded
(\code{FALSE}).}

\item{dist}{specification of the random distribution to use to draw the entries
of the basis and coefficient matrices.
It may be specified as:
\itemize{

\item a \code{function} which must be a distribution function such as e.g.
\code{\link{runif}} that is used to draw the entries of both the basis and
coefficient matrices. It is passed in the \code{dist} argument of
\code{\link{rmatrix}}.

\item a \code{list} of arguments that are passed internally to \code{\link{rmatrix}},
via \code{do.call('rmatrix', dist)}.

\item a \code{character} string that is partially matched to \sQuote{basis} or
\sQuote{coef}, that specifies which matrix in should be drawn randomly, the
other remaining as in \code{x} -- unchanged.

\item a \code{list} with elements \sQuote{basis} and/or \sQuote{coef}, which
specify the \code{dist} argument separately for the basis and coefficient
matrix respectively.

These elements may be either a distribution function, or a list of arguments that
are passed internally to \code{\link{rmatrix}}, via
\code{do.call('rmatrix', dist$basis)}
or \code{do.call('rmatrix', dist$coef)}.
}}

\item{x}{an NMF object, as returned by \code{\link{nmf}}.}
}
\value{
an NMF object
}
\description{
The class \code{NMF} is a \emph{virtual class} that defines a common
interface to handle Nonnegative Matrix Factorization models (NMF models)
in a generic way.
Provided a minimum set of generic methods is implemented by concrete
model classes, these benefit from a whole set of functions and utilities
to perform common computations and tasks in the context of Nonnegative Matrix
Factorization.
}
\details{
Class \code{NMF} makes it easy to develop new models that integrate well
into the general framework implemented by the \emph{NMF} package.

Following a few simple guidelines, new types of NMF models benefit from all the
functionalities available for the built-in NMF models -- that derive themselves
from class \code{NMF}.
See section \emph{Implementing NMF models} below.

See \code{\linkS4class{NMFstd}}, and references and links therein for
details on the built-in implementations of the standard NMF model and its
extensions.
}
\section{Slots}{

\describe{
\item{\code{misc}}{A list that is used internally to temporarily store algorithm
parameters during the computation.}
}}

\section{Implementing NMF models}{


The class \code{NMF} only defines a basic data/low-level interface for NMF models, as
a collection of generic methods, responsible with data handling, upon which
relies a comprehensive set of functions, composing a rich higher-level interface.

Actual NMF models are defined as sub-classes that inherits from class
\code{NMF}, and implement the management of data storage, providing
definitions for the interface's pure virtual methods.

The minimum requirement to define a new NMF model that integrates into
the framework of the \emph{NMF} package are the followings:

\itemize{

\item Define a class that inherits from class \code{NMF} and implements the
new model, say class \code{myNMF}.

\item Implement the following S4 methods for the new class \code{myNMF}:
\describe{
\item{fitted}{\code{signature(object = "myNMF", value = "matrix")}:
Must return the estimated target matrix as fitted by the NMF model
\code{object}.
}
\item{basis}{\code{signature(object = "myNMF")}:
Must return the basis matrix(e.g. the first matrix factor in
the standard NMF model).
}
\item{basis<-}{\code{signature(object = "myNMF", value = "matrix")}:
Must return \code{object} with the basis matrix set to
\code{value}.
}
\item{coef}{\code{signature(object = "myNMF")}:
Must return the matrix of mixture coefficients (e.g. the second matrix
factor in the standard NMF model).
}
\item{coef<-}{\code{signature(object = "myNMF", value = "matrix")}:
Must return \code{object} with the matrix of mixture coefficients set to
\code{value}.
}
}\preformatted{The \\emph\{NMF\} package provides "pure virtual" definitions of these
}

methods for class \code{NMF} (i.e. with signatures \code{(object='NMF', ...)}
and \code{(object='NMF', value='matrix')}) that throw an error if called, so
as to force their definition for model classes.

\item Optionally, implement method \code{rnmf}(signature(x="myNMF", target="ANY")).
This method should call \code{callNextMethod(x=x, target=target, ...)} and
fill the returned NMF model with its specific data suitable random values.
}

For concrete examples of NMF models implementations, see class
\code{\linkS4class{NMFstd}} and its extensions (e.g. classes
\code{\linkS4class{NMFOffset}} or \code{\linkS4class{NMFns}}).
}

\section{Creating NMF objects}{

Strictly speaking, because class \code{NMF} is virtual, no object of class
\code{NMF} can be instantiated, only objects from its sub-classes.
However, those objects are sometimes shortly referred in the documentation and
vignettes as "\code{NMF} objects" instead of "objects that inherits from
class \code{NMF}".

For built-in models or for models that inherit from the standard model class
\code{\linkS4class{NMFstd}}, the factory method \code{nmfModel} enables to easily create
valid \code{NMF} objects in a variety of common situations.
See documentation for the the factory method \code{\link{nmfModel}} for
more details.
}

\examples{

# show all the NMF models available (i.e. the classes that inherit from class NMF)
nmfModels()
# show all the built-in NMF models available
nmfModels(builtin.only=TRUE)

# class NMF is a virtual class so cannot be instantiated: 
try( new('NMF') )

# To instantiate an NMF model, use the factory method nmfModel. see ?nmfModel
nmfModel()
nmfModel(3)
nmfModel(3, model='NMFns')


# random 3-rank 10x5 NMF model
x <- rnmf(3, 10, 5)

# rescale based on basis
colSums(basis(x))
colSums(basis(scale(x)))

rx <- scale(x, 'basis', 10)
colSums(basis(rx))
rowSums(coef(rx))

# rescale based on coef
rowSums(coef(x))
rowSums(coef(scale(x, 'coef')))
rx <- scale(x, 'coef', 10)
rowSums(coef(rx))
colSums(basis(rx))

# fitted target matrix is identical but the factors have been rescaled
rx <- scale(x, 'basis')
all.equal(fitted(x), fitted(rx))
all.equal(basis(x), basis(rx))

# generate noisy fitted target from an NMF model (the true model)
gr <- as.numeric(mapply(rep, 1:3, 3))
h <- outer(1:3, gr, '==') + 0 
x <- rnmf(10, H=h)
y <- rmatrix(x)
\dontrun{
# show heatmap of the noisy target matrix: block patterns should be clear
aheatmap(y) 
}
\dontshow{ stopifnot( identical(dim(y), dim(x)[1:2]) ) }

# test NMF algorithm on noisy data
# add some noise to the true model (drawn from uniform [0,1])
res <- nmf(rmatrix(x), 3)
summary(res)

# add more noise to the true model (drawn from uniform [0,10])
res <- nmf(rmatrix(x, max=10), 3)
summary(res)


# random target matrix
v <- rmatrix(20, 10)
# fit an NMF model
x <- nmf(v, 5)
 
# predicted column and row clusters
predict(x)
predict(x, 'rows')

# with relative contributions of each basis component
predict(x, prob=TRUE)
predict(x, 'rows', prob=TRUE)


# random mixed signed NMF model 
M <- nmfModel(rmatrix(10, 3, rnorm), rmatrix(3, 4))
# split positive and negative part
nnM <- posneg(M)
M2 <- rposneg(nnM)
identical(M, M2)

x <- rnmf(3, 100, 20)
x
# transpose
y <- t(x)
y

# factors are swapped-transposed
stopifnot( identical(basis(y), t(coef(x))) )
stopifnot( identical(coef(y), t(basis(x))) )


x <- rmatrix(100, 20, dimnames = list(paste0('a', 1:100), letters[1:20]))
# NB: using low value for maxIter for the example purpose only
res <- nmf(x, 4, nrun = 5, maxIter = 50)

# sample clustering from best fit
plot(silhouette(res))

# from consensus
plot(silhouette(res, what = 'consensus'))

# feature clustering
plot(silhouette(res, what = 'features')) 

# average silhouette are computed in summary measures
summary(res)

# consensus silhouettes are ordered as on default consensusmap heatmap
\dontrun{ op <- par(mfrow = c(1,2)) }
consensusmap(res)
si <- silhouette(res, what = 'consensus')
plot(si)
\dontrun{ par(op) }

# if the order is based on some custom numeric weights
\dontrun{ op <- par(mfrow = c(1,2)) }
cm <- consensusmap(res, Rowv = runif(ncol(res)))
# NB: use reverse order because silhouettes are plotted top-down
si <- silhouette(res, what = 'consensus', order = rev(cm$rowInd))
plot(si)
\dontrun{ par(op) }

# do the reverse: order the heatmap as a set of silhouettes
si <- silhouette(res, what = 'features')
\dontrun{ op <- par(mfrow = c(1,2)) } 
basismap(res, Rowv = si)
plot(si)
\dontrun{ par(op) }


## random NMF of same class and rank as another model

x <- nmfModel(3, 10, 5)
x
rnmf(x, 20) # square
rnmf(x, 20, 13)
rnmf(x, c(20, 13))

# using another distribution
rnmf(x, 20, dist=rnorm) 

# other than standard model
y <- rnmf(3, 50, 10, model='NMFns')
y
\dontshow{ stopifnot( identical(dim(y), c(50L,10L,3L)) ) }
\dontshow{ stopifnot( is(y, 'NMFns') ) }

## random NMF from another model

a <- nmfModel(3, 100, 20)
b <- rnmf(a)
\dontshow{ stopifnot( !nmf.equal(a,b) ) }

}
\references{
Definition of Nonnegative Matrix Factorization in its modern formulation: Lee DD, Seung HS (1999). “Learning the parts of objects by non-negative
matrix factorization.” _Nature_, *401*(6755), 788-91. ISSN 0028-0836,
doi: 10.1038/44565 (URL: https://doi.org/10.1038/44565).

Historical first definition and algorithms: Paatero P, Tapper U (1994). “Positive matrix factorization: A
non-negative factor model with optimal utilization of error estimates
of data values.” _Environmetrics_, *5*(2), 111-126. doi:
10.1002/env.3170050203 (URL: https://doi.org/10.1002/env.3170050203).

Kim H, Park H (2007). “Sparse non-negative matrix factorizations via
alternating non-negativity-constrained least squares for microarray
data analysis.” _Bioinformatics (Oxford, England)_, *23*(12), 1495-502.
ISSN 1460-2059, doi: 10.1093/bioinformatics/btm134 (URL:
https://doi.org/10.1093/bioinformatics/btm134).
}
\seealso{
Main interface function \link{nmf} to perform NMF.

Built-in NMF models and factory method in \code{\link{nmfModel}}.

Method \code{\link{seed}} to set NMF objects with values suitable to start
algorithms with.

\code{\link[NMF]{predict}}

Other NMF-interface: 
\code{\link{basis}()},
\code{\link{nmfModel}()},
\code{\link{rnmf}()}

Other stats: 
\code{\link{deviance}()},
\code{\link{residuals}()}

Other transforms: 
\code{\link{nneg}()}
}
\concept{NMF-interface}
\concept{NMF-model Implementations of NMF models}
\concept{stats}
\concept{transforms}
\keyword{internal}
\section{Methods (by generic)}{
\bold{.basis:}

\itemize{
\item \code{.basis(object = NMF)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{.basis<-:}

\itemize{
\item \code{.basis<-(object = NMF,value = mMatrix)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{.coef:}

\itemize{
\item \code{.coef(object = NMF)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{.coef<-:}

\itemize{
\item \code{.coef<-(object = NMF,value = mMatrix)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{[:}

\itemize{
\item \code{[(x = NMF)}: Sub-setting NMF Objects

This method provides a convenient way of sub-setting objects of class \code{NMF},
using a matrix-like syntax.
}


\bold{$:}

\itemize{
\item \code{$(x = NMF)}: shortcut for \code{x@misc[[name, exact=TRUE]]} respectively.
}


\bold{$<-:}

\itemize{
\item \code{$<-(x = NMF)}: shortcut for \code{x@misc[[name]] <- value}
}


\bold{basis<-:}

\itemize{
\item \code{basis<-(object = NMF)}: Default methods that calls \code{.basis<-} and check the validity of the
updated object.
}


\bold{basiscor:}

\itemize{
\item \code{basiscor(x = NMF,y = matrix)}: Computes the correlations between the basis vectors of \code{x} and
the columns of \code{y}.

\item \code{basiscor(x = matrix,y = NMF)}: Computes the correlations between the columns of \code{x}
and the the basis vectors of \code{y}.

\item \code{basiscor(x = NMF,y = NMF)}: Computes the correlations between the basis vectors of \code{x} and \code{y}.

\item \code{basiscor(x = NMF,y = missing)}: Computes the correlations between the basis vectors of \code{x}.
}


\bold{basismap:}

\itemize{
\item \code{basismap(object = NMF)}: Plots a heatmap of the basis matrix of the NMF model \code{object}.
This method also works for fitted NMF models (i.e. \code{NMFfit} objects).
}


\bold{c:}

\itemize{
\item \code{c(x = NMF)}: Concatenating NMF Models

Binds compatible matrices and NMF models together.
}


\bold{canFit:}

\itemize{
\item \code{canFit(x = NMFStrategy,y = NMF)}: Tells if an NMF algorithm can fit the same class of models as \code{y}
}


\bold{coef:}

\itemize{
\item \code{coef(object = NMF)}: Get/Set the Coefficient Matrix in NMF Models

\code{coef} and \code{coef<-} respectively extract and set the
coefficient matrix of an NMF model (i.e. the second matrix factor).
For example, in the case of the standard NMF model \eqn{V \equiv WH}{V ~ W H},
the method \code{coef} will return the matrix \eqn{H}.

\code{coef} and \code{coef<-} are S4 methods defined for the corresponding
generic functions from package \code{stats} (See \link[stats:coef]{stats::coef}).
Similarly to \code{basis} and \code{basis<-}, they are defined for the top
virtual class \code{\linkS4class{NMF}} only, and rely internally on the S4
generics \code{.coef} and \code{.coef<-} respectively that effectively
extract/set the coefficient data.
These data are post/pre-processed, e.g., to extract/set only their
non-fixed terms or check dimension compatibility.
}


\bold{coef<-:}

\itemize{
\item \code{coef<-(object = NMF)}: Default methods that calls \code{.coef<-} and check the validity of the
updated object.
}


\bold{coefficients:}

\itemize{
\item \code{coefficients(object = NMF)}: Alias to \code{coef,NMF}, therefore also pure virtual.
}


\bold{coefmap:}

\itemize{
\item \code{coefmap(object = NMF)}: The default method for NMF objects has special default values for
some arguments of \code{\link{aheatmap}} (see argument description).
}


\bold{connectivity:}

\itemize{
\item \code{connectivity(object = NMF)}: Computes the connectivity matrix for an NMF model, for which cluster
membership is given by the most contributing basis component in each sample.
See \code{\link{predict,NMF-method}}.
}


\bold{consensus:}

\itemize{
\item \code{consensus(object = NMF)}: This method is provided for completeness and is identical to
\code{\link{connectivity}}, and returns the connectivity matrix,
which, in the case of a single NMF model, is also the consensus matrix.
}


\bold{consensushc:}

\itemize{
\item \code{consensushc(object = NMF)}: Compute the hierarchical clustering on the connectivity matrix of \code{object}.
}


\bold{consensusmap:}

\itemize{
\item \code{consensusmap(object = NMF)}: Plots a heatmap of the connectivity matrix of an NMF model.
}


\bold{deviance:}

\itemize{
\item \code{deviance(object = NMF)}: Computes the distance between a matrix and the estimate of an \code{NMF} model.
}


\bold{dim:}

\itemize{
\item \code{dim(x = NMF)}: method for NMF objects for the base generic \code{\link{dim}}.
It returns all dimensions in a length-3 integer vector:
the number of row and columns of the estimated target matrix,
as well as the factorization rank (i.e. the number of basis components).
}


\bold{dimnames:}

\itemize{
\item \code{dimnames(x = NMF)}: Returns the dimension names of the NMF model \code{x}.

It returns either NULL if no dimnames are set on the object,
or a 3-length list containing the row names of the basis matrix,
the column names of the mixture coefficient matrix, and the column names of
the basis matrix (i.e. the names of the basis components).
}


\bold{dimnames<-:}

\itemize{
\item \code{dimnames<-(x = NMF)}: sets the dimension names of the NMF model \code{x}.

\code{value} can be \code{NULL} which resets all dimension names, or a
1, 2 or 3-length list providing names at least for the rows of the basis
matrix.

The optional second element of \code{value} (NULL if absent) is used to set
the column names of the coefficient matrix.
The optional third element of \code{value} (NULL if absent) is used to set
both the column names of the basis matrix and the row names of the
coefficient matrix.
}


\bold{extractFeatures:}

\itemize{
\item \code{extractFeatures(object = NMF)}: Select basis-specific features from an NMF model, by applying the method
\code{extractFeatures,matrix} to its basis matrix.
}


\bold{featureScore:}

\itemize{
\item \code{featureScore(object = NMF)}: Computes feature scores on the basis matrix of an NMF model.
}


\bold{fit<-:}

\itemize{
\item \code{fit<-(object = NMFfit,value = NMF)}: Updates the NMF model object stored in slot \code{'fit'} with a new value.
}


\bold{fitted:}

\itemize{
\item \code{fitted(object = NMF)}: Pure virtual method for objects of class \code{\linkS4class{NMF}}, that
should be overloaded by sub-classes, and throws an error if called.
}


\bold{ibterms:}

\itemize{
\item \code{ibterms(object = NMF)}: Default pure virtual method that ensure a method is defined for concrete
NMF model classes.
}


\bold{icterms:}

\itemize{
\item \code{icterms(object = NMF)}: Default pure virtual method that ensure a method is defined for concrete
NMF model classes.
}


\bold{loadings:}

\itemize{
\item \code{loadings(x = NMF)}: Method loadings for NMF Models

The method \code{loadings} is identical to \code{basis}, but do
not accept any extra argument.
}


\bold{metaHeatmap:}

\itemize{
\item \code{metaHeatmap(object = NMF)}: Deprecated method that is substituted by \code{\link{coefmap}} and \code{\link{basismap}}.
}


\bold{nmf:}

\itemize{
\item \code{nmf(x = mMatrix,rank = NMF,method = ANY)}: Fits an NMF model using the NMF model \code{rank} to seed the computation,
i.e. as a starting point.

This method is provided for convenience as a shortcut for
\code{nmf(x, nbasis(object), method, seed=object, ...)}
It discards any value passed in argument \code{seed} and uses the NMF model passed
in \code{rank} instead.
It throws a warning if argument \code{seed} not missing.

If \code{method} is missing, this method will call the method
\code{nmf,matrix,numeric,NULL}, which will infer an algorithm suitable for fitting an
NMF model of the class of \code{rank}.
}


\bold{nmf.equal:}

\itemize{
\item \code{nmf.equal(x = NMF,y = NMF)}: Compares two NMF models.

Arguments in \code{...} are used only when \code{identical=FALSE} and are
passed to \code{all.equal}.

\item \code{nmf.equal(x = NMFfit,y = NMF)}: Compares two NMF models when at least one comes from a NMFfit object,
i.e. an object returned by a single run of \code{\link{nmf}}.

\item \code{nmf.equal(x = NMF,y = NMFfit)}: Compares two NMF models when at least one comes from a NMFfit object,
i.e. an object returned by a single run of \code{\link{nmf}}.

\item \code{nmf.equal(x = NMFfitX,y = NMF)}: Compares two NMF models when at least one comes from multiple NMF runs.

\item \code{nmf.equal(x = NMF,y = NMFfitX)}: Compares two NMF models when at least one comes from multiple NMF runs.
}


\bold{nneg:}

\itemize{
\item \code{nneg(object = NMF)}: Applies \code{nneg} to the basis matrix of an \code{\link{NMF}}
object (i.e. \code{basis(object)}).
All extra arguments in \code{...} are passed to the method \code{nneg,matrix}.
}


\bold{nrun:}

\itemize{
\item \code{nrun(object = NMF)}: This default fallback method always returns \code{1L}.
}


\bold{predict:}

\itemize{
\item \code{predict(object = NMF)}: Default method for NMF models
}


\bold{profcor:}

\itemize{
\item \code{profcor(x = NMF,y = matrix)}: Computes the correlations between the basis profiles of \code{x} and
the rows of \code{y}.

\item \code{profcor(x = matrix,y = NMF)}: Computes the correlations between the rows of \code{x} and the basis
profiles of \code{y}.

\item \code{profcor(x = NMF,y = NMF)}: Computes the correlations between the basis profiles of \code{x} and \code{y}.

\item \code{profcor(x = NMF,y = missing)}: Computes the correlations between the basis profiles of \code{x}.
}


\bold{rmatrix:}

\itemize{
\item \code{rmatrix(x = NMF)}: Returns the target matrix estimate of the NMF model \code{x}, perturbated by
adding a random matrix generated using the default method of \code{rmatrix}:
it is a equivalent to \code{fitted(x) + rmatrix(fitted(x), ...)}.

This method can be used to generate random target matrices that depart from
a known NMF model to a controlled extend.
This is useful to test the robustness of NMF algorithms to the presence of
certain types of noise in the data.
}


\bold{rnmf:}

\itemize{
\item \code{rnmf(x = NMF,target = numeric)}: Generates a random NMF model of the same class and rank as another NMF model.

This is the workhorse method that is eventually called by all other methods.
It generates an NMF model of the same class and rank as \code{x}, compatible with the
dimensions specified in \code{target}, that can be a single or 2-length
numeric vector, to specify a square or rectangular target matrix respectively.

The second dimension can also be passed via argument \code{ncol}, so that
calling \code{rnmf(x, 20, 10, ...)} is equivalent to \code{rnmf(x, c(20, 10), ...)},
but easier to write.

The entries are uniformly drawn between \code{0} and \code{max}
(optionally specified in \code{...}) that defaults to 1.

By default the dimnames of \code{x} are set on the returned NMF model.
This behaviour is disabled with argument \code{keep.names=FALSE}.
See \code{\link{nmfModel}}.

\item \code{rnmf(x = NMF,target = missing)}: Generates a random NMF model of the same dimension as another NMF model.

It is a shortcut for \code{rnmf(x, nrow(x), ncol(x), ...)}, which returns
a random NMF model of the same class and dimensions as \code{x}.
}


\bold{rposneg:}

\itemize{
\item \code{rposneg(object = NMF)}: Apply \code{rposneg} to the basis matrix of an \code{\link{NMF}} object.
}


\bold{run:}

\itemize{
\item \code{run(object = NMFStrategy,y = mMatrix,x = NMF)}: Method to run an NMF algorithm directly starting from a given NMF model.
}


\bold{scale:}

\itemize{
\item \code{scale(NMF)}: Rescaling NMF Models

Rescales an NMF model keeping the fitted target matrix identical.

Standard NMF models are identifiable modulo a scaling factor, meaning that the
basis components and basis profiles can be rescaled without changing the fitted
values:

\deqn{X = W_1 H_1 = (W_1 D) (D^{-1} H_1) = W_2 H_2}{X = W H = (W D) (D^-1 H)}
with \eqn{D= \alpha diag(1/\delta_1, \ldots, 1\delta_r)}{D= alpha * diag(1/delta_1, ..., 1/delta_r)}

The default call \code{scale(object)} rescales the basis NMF object so that each
column of the basis matrix sums up to one.
}


\bold{seed:}

\itemize{
\item \code{seed(x = mMatrix,model = NMF,method = NMFSeed)}: This is the workhorse method that seeds an NMF model object using a given
seeding strategy defined by an \code{NMFSeed} object, to fit a given
target matrix.
}


\bold{show:}

\itemize{
\item \code{show(object = NMF)}: Show method for objects of class \code{NMF}
}


\bold{silhouette:}

\itemize{
\item \code{silhouette(NMF)}: Silhouette of NMF Clustering
}


\bold{sparseness:}

\itemize{
\item \code{sparseness(x = NMF)}: Compute the sparseness of an object of class \code{NMF}, as the sparseness of
the basis and coefficient matrices computed separately.

It returns the two values in a numeric vector with names \sQuote{basis} and \sQuote{coef}.
}


\bold{summary:}

\itemize{
\item \code{summary(object = NMF)}: Computes summary measures for a single NMF model.

The following measures are computed:
}


\bold{t:}

\itemize{
\item \code{t(NMF)}: Transformation of NMF Model Objects

\code{t} transpose an NMF model, by transposing and swapping its basis and
coefficient matrices: \eqn{t([W,H]) = [t(H), t(W)]}.

The function \code{t} is a generic defined in the \pkg{base} package.
The method \code{t.NMF} defines the trasnformation for the general NMF interface.
This method may need to be overloaded for NMF models, whose structure requires
specific handling.
}

}


\section{Functions}{
\itemize{
\item \code{misc}: The function \code{misc} provides access to miscellaneous data members stored
in slot \code{misc} (as a \code{list}), which allow extensions of NMF models
to be implemented, without defining a new S4 class.
}}

