% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NMFfit-class.R, R/NMFSet-class.R,
%   R/NMFStrategy-class.R, R/NMFStrategyFunction-class.R,
%   R/NMFStrategyIterative-class.R, R/NMFStrategyOctave-class.R
\docType{class}
\name{NMFfit-class}
\alias{NMFfit-class}
\alias{NMFfit}
\alias{fitted,NMFfit-method}
\alias{.basis,NMFfit-method}
\alias{.basis<-,NMFfit,matrix-method}
\alias{.coef,NMFfit-method}
\alias{.coef<-,NMFfit,matrix-method}
\alias{ibterms,NMFfit-method}
\alias{icterms,NMFfit-method}
\alias{offset,NMFfit-method}
\alias{niter,NMFfit-method}
\alias{niter<-,NMFfit,numeric-method}
\alias{show,NMFfit-method}
\alias{fit,NMFfit-method}
\alias{minfit,NMFfit-method}
\alias{modelname,NMFfit-method}
\alias{residuals,NMFfit-method}
\alias{residuals<-,NMFfit-method}
\alias{deviance,NMFfit-method}
\alias{algorithm,NMFfit-method}
\alias{algorithm<-,NMFfit,ANY-method}
\alias{seeding,NMFfit-method}
\alias{seeding<-,NMFfit-method}
\alias{objective,NMFfit-method}
\alias{objective<-,NMFfit,ANY-method}
\alias{runtime,NMFfit-method}
\alias{runtime.all,NMFfit-method}
\alias{plot,NMFfit,missing-method}
\alias{summary,NMFfit-method}
\alias{nmf.equal,NMFfit,NMFfit-method}
\alias{nrun,NMFfit-method}
\alias{consensus,NMFfit-method}
\alias{NMFfitX,NMFfit-method}
\alias{run,NMFStrategy,mMatrix,NMFfit-method}
\alias{run,NMFStrategyFunction,matrix,NMFfit-method}
\alias{run,NMFStrategyIterative,mMatrix,NMFfit-method}
\alias{run,NMFStrategyOctave,matrix,NMFfit-method}
\title{Base Class for to store Nonnegative Matrix Factorisation results}
\usage{
NMFfit(fit = nmfModel(), ..., rng = NULL)

\S4method{fitted}{NMFfit}(object, ...)

\S4method{.basis}{NMFfit}(object, ...)

\S4method{.basis}{NMFfit,matrix}(object) <- value

\S4method{.coef}{NMFfit}(object, ...)

\S4method{.coef}{NMFfit,matrix}(object) <- value

\S4method{ibterms}{NMFfit}(object)

\S4method{icterms}{NMFfit}(object)

\S4method{offset}{NMFfit}(object)

\S4method{niter}{NMFfit}(object, ...)

\S4method{niter}{NMFfit,numeric}(object) <- value

\S4method{show}{NMFfit}(object)

\S4method{fit}{NMFfit}(object)

\S4method{minfit}{NMFfit}(object)

\S4method{modelname}{NMFfit}(object)

\S4method{residuals}{NMFfit}(object, track = FALSE, niter = NULL, ...)

\S4method{residuals}{NMFfit}(object, ..., niter = NULL, track = FALSE) <- value

\S4method{deviance}{NMFfit}(object, y, method, ...)

\S4method{algorithm}{NMFfit}(object)

\S4method{algorithm}{NMFfit,ANY}(object) <- value

\S4method{seeding}{NMFfit}(object)

\S4method{seeding}{NMFfit}(object) <- value

\S4method{objective}{NMFfit}(object, y)

\S4method{objective}{NMFfit,ANY}(object) <- value

\S4method{runtime}{NMFfit}(object, ...)

\S4method{runtime.all}{NMFfit}(object, ...)

\S4method{plot}{NMFfit,missing}(x, y, skip = -1L, ...)

\S4method{summary}{NMFfit}(object, ...)

\S4method{nmf.equal}{NMFfit,NMFfit}(x, y, ...)

\S4method{nrun}{NMFfit}(object)

\S4method{consensus}{NMFfit}(object, ...)

\S4method{icterms}{NMFfit}(object)

\S4method{NMFfitX}{NMFfit}(object, ...)

\S4method{run}{NMFStrategy,mMatrix,NMFfit}(object, y, x, ...)

\S4method{run}{NMFStrategyFunction,matrix,NMFfit}(object, y, x, ...)

\S4method{run}{NMFStrategyIterative,mMatrix,NMFfit}(
  object,
  y,
  x,
  .stop = NULL,
  maxIter = nmf.getOption("maxIter") \%||\% 2000L,
  ...
)

\S4method{run}{NMFStrategyOctave,matrix,NMFfit}(object, y, x, ...)
}
\arguments{
\item{fit}{an NMF model}

\item{...}{other arguments passed as parameters to the algorithm's Octave implementation.}

\item{rng}{RNG settings specification (typically a suitable value for
\code{\link{.Random.seed}}).}

\item{object}{an object of class \code{NMFStrategyOctave}, which encapsulates the Octave \code{NMF} algorithm
to run, access or modify.}

\item{value}{an object used to modify the properties of the object.
Depending on the method, it may be a \code{matrix}, \code{numeric}, an \linkS4class{NMF} model object, etc...}

\item{track}{a logical that indicates if the complete track of residuals
should be returned (if it has been computed during the fit), or only the last
value.}

\item{niter}{specifies the iteration number for which one wants
to get/set/test a residual value. This argument is used only if not \code{NULL}}

\item{y}{the target data that we want to approximate, passed as a matrix(-like) object.}

\item{method}{a character string or a function with signature
\code{(x="NMF", y="matrix", ...)} that implements a distance measure between
an NMF model \code{x} and a target matrix \code{y}, i.e. an objective function
to use to compute the deviance.
In \code{deviance}, it is passed to \code{nmfDistance} to get the function
that effectively computes the deviance.}

\item{x}{an \linkS4class{NMFfit} object used as a starting point/seed by the algorithm.}

\item{skip}{an integer that indicates the number of points to skip/remove from the beginning
of the curve.
If \code{skip=1L} (default) only the initial residual -- that is computed before any iteration, is
skipped, if present in the track (it associated with iteration 0).}

\item{.stop}{specification of a stopping criterion, that is used instead of the
one associated to the NMF algorithm.
It may be specified as:
\itemize{
\item the access key of a registered stopping criterion;
\item a single integer that specifies the exact number of iterations to perform, which will
be honoured unless a lower value is explicitly passed in argument \code{maxIter}.
\item a single numeric value that specifies the stationnarity threshold for the
objective function, used in with \code{\link{nmf.stop.stationary}};
\item a function with signature \code{(object="NMFStrategy", i="integer", y="matrix", x="NMF", ...)},
where \code{object} is the \code{NMFStrategy} object that describes the algorithm being run,
\code{i} is the current iteration, \code{y} is the target matrix and \code{x} is the current value of
the NMF model.
}}

\item{maxIter}{maximum number of iterations to perform.}
}
\description{
Base class to handle the results of general \strong{Nonnegative Matrix
Factorisation} algorithms (NMF).
}
\details{
It provides a general structure and generic functions to manage the results
of NMF algorithms.  It contains a slot with the fitted NMF model (see slot
\code{fit}) as well as data about the methods and parameters used to compute
the factorization.

The purpose of this class is to handle in a generic way the results of NMF
algorithms. Its slot \code{fit} contains the fitted NMF model as an object
of class \code{\linkS4class{NMF}}.

Other slots contains data about how the factorization has been computed,
such as the algorithm and seeding method, the computation time, the final
residuals, etc\dots{}

Class \code{NMFfit} acts as a wrapper class for its slot \code{fit}.  It
inherits from interface class \code{\linkS4class{NMF}} defined for generic
NMF models.  Therefore, all the methods defined by this interface can be
called directly on objects of class \code{NMFfit}. The calls are simply
dispatched on slot \code{fit}, i.e.  the results are the same as if calling
the methods directly on slot \code{fit}.
}
\section{Slots}{

\describe{
\item{\code{fit}}{An object that inherits from class \code{\linkS4class{NMF}}, and
contains the fitted NMF model.

NB: class \code{NMF} is a virtual class. The default class for this
slot is \code{NMFstd}, that implements the standard NMF model.}

\item{\code{residuals}}{A \code{numeric} vector that contains the final
residuals or the residuals track between the target matrix and its NMF
estimate(s).  Default value is \code{numeric()}.

See method \code{\link{residuals}} for details on accessor methods and main
interface \code{\link{nmf}} for details on how to compute NMF with residuals
tracking.}

\item{\code{method}}{a single \code{character} string that contains the
name of the algorithm used to fit the model.
Default value is \code{''}.}

\item{\code{seed}}{a single \code{character} string that contains the
name of the seeding method used to seed the algorithm that fitted the NMF
model.
Default value is \code{''}.  See \code{\link{nmf}} for more details.}

\item{\code{rng}}{an object that contains the RNG settings used for the
fit.
Currently the settings are stored as an integer vector, the value of
\code{\link{.Random.seed}} at the time the object is created.
It is initialized by the \code{initialized} method.
See \code{\link{getRNG}} for more details.}

\item{\code{distance}}{either a single \code{"character"} string that
contains the name of the built-in objective function, or a \code{function}
that measures the residuals between the target matrix and its NMF estimate.
See \code{\link{objective}} and \code{\link{deviance,NMF-method}}.}

\item{\code{parameters}}{a \code{list} that contains the extra parameters
-- usually specific to the algorithm -- that were used to fit the model.}

\item{\code{runtime}}{object of class \code{"proc_time"} that contains
various measures of the time spent to fit the model.
See \code{\link[base]{system.time}}}

\item{\code{options}}{a \code{list} that contains the options used to
compute the object.}

\item{\code{extra}}{a \code{list} that contains extra miscellaneous data
for internal usage only.
For example it can be used to store extra parameters or temporary data,
without the need to explicitly extend the \code{NMFfit} class.
Currently built-in algorithms only use this slot to
store the number of iterations performed to fit the object.

Data that need to be easily accessible by the end-user should rather be set
using the methods \code{$<-} that sets elements in the \code{list} slot
\code{misc} -- that is inherited from class \code{\linkS4class{NMF}}.}

\item{\code{call}}{stored call to the last \code{nmf} method that generated the
object.}
}}

\examples{
# run default NMF algorithm on a random matrix
n <- 50; r <- 3; p <- 20
V <- rmatrix(n, p)  
res <- nmf(V, r)							

# result class is NMFfit
class(res)
isNMFfit(res)

# show result
res

# compute summary measures
summary(res, target=V)

# generate a synthetic dataset with known classes: 50 features, 18 samples (5+5+8)
n <- 50; counts <- c(5, 5, 8);
V <- syntheticNMF(n, counts)
cl <- unlist(mapply(rep, 1:3, counts))

# perform default NMF with rank=2
x2 <- nmf(V, 2)
summary(x2, cl, V)
# perform default NMF with rank=2
x3 <- nmf(V, 3)
summary(x2, cl, V)

}
\section{Methods (by generic)}{
\bold{.basis:}

\itemize{
\item \code{.basis(object = NMFfit)}: Returns the basis matrix from an NMF model fitted with
function \code{\link{nmf}}.

It is a shortcut for \code{.basis(fit(object), ...)}, dispatching the call to
the \code{.basis} method of the actual NMF model.
}


\bold{.basis<-:}

\itemize{
\item \code{.basis<-(object = NMFfit,value = matrix)}: Sets the the basis matrix of an NMF model fitted with
function \code{\link{nmf}}.

It is a shortcut for \code{.basis(fit(object)) <- value}, dispatching the call to
the \code{.basis<-} method of the actual NMF model.
It is not meant to be used by the user, except when developing
NMF algorithms, to update the basis matrix of the seed object before
returning it.
}


\bold{.coef:}

\itemize{
\item \code{.coef(object = NMFfit)}: Returns the the coefficient matrix from an NMF model fitted with
function \code{\link{nmf}}.

It is a shortcut for \code{.coef(fit(object), ...)}, dispatching the call to
the \code{.coef} method of the actual NMF model.
}


\bold{.coef<-:}

\itemize{
\item \code{.coef<-(object = NMFfit,value = matrix)}: Sets the the coefficient matrix of an NMF model fitted with
function \code{\link{nmf}}.

It is a shortcut for \code{.coef(fit(object)) <- value}, dispatching the call to
the \code{.coef<-} method of the actual NMF model.
It is not meant to be used by the user, except when developing
NMF algorithms, to update the coefficient matrix in the seed object before
returning it.
}


\bold{algorithm:}

\itemize{
\item \code{algorithm(object = NMFfit)}: Returns the name of the algorithm that fitted the NMF model \code{object}.
}


\bold{compare:}

\itemize{
\item \code{compare(object = NMFfit)}: Compare multiple NMF fits passed as arguments.
}


\bold{consensus:}

\itemize{
\item \code{consensus(object = NMFfit)}: Shorcut for \code{consensus(fit(object), ...)}
}


\bold{deviance:}

\itemize{
\item \code{deviance(object = NMFfit)}: Returns the deviance of a fitted NMF model.

This method returns the final residual value if the target matrix \code{y} is
not supplied, or the approximation error between the fitted NMF model stored
in \code{object} and \code{y}.
In this case, the computation is performed using the objective function
\code{method} if not missing, or the objective of the algorithm that
fitted the model (stored in slot \code{'distance'}).

If not computed by the NMF algorithm itself, the value is automatically
computed at the end of the fitting process by the function \code{\link{nmf}},
using the objective function associated with the NMF algorithm, so that it
should always be available.
}


\bold{fit:}

\itemize{
\item \code{fit(object = NMFfit)}: Returns the NMF model object stored in slot \code{'fit'}.
}


\bold{fit<-:}

\itemize{
\item \code{fit<-(object = NMFfit,value = NMF)}: Updates the NMF model object stored in slot \code{'fit'} with a new value.
}


\bold{fitted:}

\itemize{
\item \code{fitted(object = NMFfit)}: Computes and return the estimated target matrix from an NMF model fitted with
function \code{\link{nmf}}.

It is a shortcut for \code{fitted(fit(object), ...)}, dispatching the call to
the \code{fitted} method of the actual NMF model.
}


\bold{ibterms:}

\itemize{
\item \code{ibterms(object = NMFfit)}: Method for single NMF fit objects, which returns the indexes of fixed
basis terms from the fitted model.
}


\bold{icterms:}

\itemize{
\item \code{icterms(object = NMFfit)}: Method for single NMF fit objects, which returns the indexes of fixed
coefficient terms from the fitted model.

\item \code{icterms(object = NMFfit)}: Method for multiple NMF fit objects, which returns the indexes of fixed
coefficient terms from the best fitted model.
}


\bold{minfit:}

\itemize{
\item \code{minfit(object = NMFfit)}: Returns the object its self, since there it is the result of a single NMF run.
}


\bold{modelname:}

\itemize{
\item \code{modelname(object = NMFfit)}: Returns the type of a fitted NMF model.
It is a shortcut for \code{modelname(fit(object)}.
}


\bold{niter:}

\itemize{
\item \code{niter(object = NMFfit)}: Returns the number of iteration performed to fit an NMF model, typically
with function \code{\link{nmf}}.

Currently this data is stored in slot \code{'extra'}, but this might change
in the future.
}


\bold{niter<-:}

\itemize{
\item \code{niter<-(object = NMFfit,value = numeric)}: Sets the number of iteration performed to fit an NMF model.

This function is used internally by the function \code{\link{nmf}}.
It is not meant to be called by the user, except when developing
new NMF algorithms implemented as single function, to set the number
of iterations performed by the algorithm on the seed, before returning it
(see \code{\linkS4class{NMFStrategyFunction}}).
}


\bold{nmf.equal:}

\itemize{
\item \code{nmf.equal(x = NMFfit,y = NMF)}: Compares two NMF models when at least one comes from a NMFfit object,
i.e. an object returned by a single run of \code{\link{nmf}}.

\item \code{nmf.equal(x = NMF,y = NMFfit)}: Compares two NMF models when at least one comes from a NMFfit object,
i.e. an object returned by a single run of \code{\link{nmf}}.

\item \code{nmf.equal(x = NMFfit,y = NMFfit)}: Compares two fitted NMF models, i.e. objects returned by single runs of
\code{\link{nmf}}.
}


\bold{NMFfitX:}

\itemize{
\item \code{NMFfitX(object = NMFfit)}: Creates an \code{NMFfitX1} object from a single fit.
This is used in \code{\link{nmf}} when only the best fit is kept in memory or
on disk.
}


\bold{nrun:}

\itemize{
\item \code{nrun(object = NMFfit)}: This method returns  the number of runs used to compute a fitted NMF model (in \code{fit(object)}).
This will be \code{1L} most of the time, since an \code{NMFfit} object is generally from a
single NMF run, except in special nested fits.
}


\bold{objective:}

\itemize{
\item \code{objective(object = NMFfit)}: Returns the objective function associated with the algorithm that computed the
fitted NMF model \code{object}, or the objective value with respect to a given
target matrix \code{y} if it is supplied.
}


\bold{offset:}

\itemize{
\item \code{offset(object = NMFfit)}: Returns the offset from the fitted model.
}


\bold{plot:}

\itemize{
\item \code{plot(x = NMFfit,y = missing)}: Plots the residual track computed at regular interval during the fit of
the NMF model \code{x}.
}


\bold{residuals:}

\itemize{
\item \code{residuals(object = NMFfit)}: Returns the residuals -- track -- between the target matrix and the NMF
fit \code{object}.
}


\bold{run:}

\itemize{
\item \code{run(object = NMFStrategy,y = mMatrix,x = NMFfit)}: Pure virtual method defined for all NMF algorithms to ensure
that a method \code{run} is defined by sub-classes of \code{NMFStrategy}.

It throws an error if called directly.

\item \code{run(object = NMFStrategyFunction,y = matrix,x = NMFfit)}: Runs the NMF algorithms implemented by the single R function -- and stored in slot \code{'algorithm'}
of \code{object}, on the data object \code{y}, using \code{x} as starting point.
It is equivalent to calling \code{object@algorithm(y, x, ...)}.

This method is usually not called directly, but only via the function \code{\link{nmf}}, which
takes care of many other details such as seeding the computation, handling RNG settings, or setting up
parallelisation.

\item \code{run(object = NMFStrategyIterative,y = mMatrix,x = NMFfit)}: Runs an NMF iterative algorithm on a target matrix \code{y}.

\item \code{run(object = NMFStrategyOctave,y = matrix,x = NMFfit)}: Runs the NMF algorithms implemented by the Octave/Matlab function associated with the
strategy -- and stored in slot \code{'algorithm'} of \code{object}.

This method is usually not called directly, but only via the function \code{\link{nmf}}, which
takes care of many other details such as seeding the computation, handling RNG settings,
or setting up parallel computations.
}


\bold{runtime:}

\itemize{
\item \code{runtime(object = NMFfit)}: Returns the CPU time required to compute a single NMF fit.
}


\bold{runtime.all:}

\itemize{
\item \code{runtime.all(object = NMFfit)}: Identical to \code{runtime}, since their is a single fit.
}


\bold{seeding:}

\itemize{
\item \code{seeding(object = NMFfit)}: Returns the name of the seeding method that generated the starting point
for the NMF algorithm that fitted the NMF model \code{object}.
}


\bold{show:}

\itemize{
\item \code{show(object = NMFfit)}: Show method for objects of class \code{NMFfit}
}


\bold{summary:}

\itemize{
\item \code{summary(object = NMFfit)}: Computes summary measures for a single fit from \code{\link{nmf}}.

This method adds the following measures to the measures computed by the method
\code{summary,NMF}:

\describe{
\item{residuals}{Residual error as measured by the objective function associated
to the algorithm used to fit the model.}
\item{niter}{Number of iterations performed to achieve convergence of the algorithm.}
\item{cpu}{Total CPU time required for the fit.}
\item{cpu.all}{Total CPU time required for the fit. For \code{NMFfit} objects, this element is
always equal to the value in \dQuote{cpu}, but will be different for multiple-run fits.}
\item{nrun}{Number of runs performed to fit the model. This is always equal to 1 for
\code{NMFfit} objects, but will vary for multiple-run fits.}
}
}

}

