% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NMFstd-class.R, R/fixed-terms.R
\docType{class}
\name{NMFstd-class}
\alias{NMFstd-class}
\alias{show,NMFstd-method}
\alias{.basis,NMFstd-method}
\alias{.basis<-,NMFstd,array-method}
\alias{.basis<-,NMFstd,mMatrix-method}
\alias{.coef,NMFstd-method}
\alias{.coef<-,NMFstd,array-method}
\alias{.coef<-,NMFstd,mMatrix-method}
\alias{fitted,NMFstd-method}
\alias{bterms<-,NMFstd-method}
\alias{cterms<-,NMFstd-method}
\alias{ibterms,NMFstd-method}
\alias{icterms,NMFstd-method}
\title{NMF Model - Standard model}
\usage{
\S4method{show}{NMFstd}(object)

\S4method{.basis}{NMFstd}(object, slice = NULL)

\S4method{.basis}{NMFstd,array}(object) <- value

\S4method{.basis}{NMFstd,mMatrix}(object, slice = 1L) <- value

\S4method{.coef}{NMFstd}(object, slice = NULL)

\S4method{.coef}{NMFstd,array}(object) <- value

\S4method{.coef}{NMFstd,mMatrix}(object, slice = 1L) <- value

\S4method{fitted}{NMFstd}(object, W, H)

\S4method{bterms}{NMFstd}(object) <- value

\S4method{cterms}{NMFstd}(object) <- value

\S4method{ibterms}{NMFstd}(object)

\S4method{icterms}{NMFstd}(object)
}
\arguments{
\item{object}{an object of class \code{NMFstd}.}

\item{slice}{optional slice (3rd margin) to extract in 3D-array NMF models.}

\item{value}{an object whose value is used to modify properties of the given
object.}

\item{W}{a optional matrix to use in the computation as the basis matrix in place of
\code{basis(object)}.
It must be compatible with the coefficient matrix used in the computation.
That is, number of columns in \code{W} = number of rows in the mixture coefficient matrix \code{coef(object)} or \code{H} (if provided).}

\item{H}{a optional matrix to use in the computation as the coefficient matrix in place of
\code{coef(object)}.
It must be compatible with the basis matrix used in the computation.
That is, number of rows in \code{H} = number of columns in the basis matrix \code{basis(object)} or \code{W} (if provided).}
}
\description{
This class implements the standard model of Nonnegative Matrix
Factorization.
It provides a general structure and generic functions to manage
factorizations that follow the standard NMF model, as defined by
Lee and Seung (2001).
}
\details{
Let \eqn{V} be a \eqn{n \times m} non-negative matrix and \eqn{r} a positive
integer.  In its standard form (see references below), a NMF of \eqn{V} is
commonly defined as a pair of matrices \eqn{(W, H)} such that:

\deqn{V \equiv W H,}

where:
\itemize{
\item \eqn{W} and \eqn{H} are \eqn{n \times r} and \eqn{r
\times m} matrices respectively with non-negative entries;
\item \eqn{\equiv} is to be understood with respect to some loss function.
Common choices of loss functions are based on Frobenius norm or Kullback-Leibler
divergence.
}

Integer \eqn{r} is called the \emph{factorization rank}.
Depending on the context of application of NMF, the columns of \eqn{W}
and \eqn{H} are given different names:
\describe{
\item{columns of \code{W}}{basis vector, metagenes, factors, source, image basis}
\item{columns of \code{H}}{mixture coefficients, metagene sample expression profiles, weights}
\item{rows of \code{H}}{basis profiles, metagene expression profiles}
}

NMF approaches have been successfully applied to several fields.
The package NMF was implemented trying to use names as generic as possible
for objects and methods.

The following terminology is used:
\describe{
\item{samples}{the columns of the target matrix \eqn{V}}
\item{features}{the rows of the target matrix \eqn{V}}
\item{basis matrix}{the first matrix factor \eqn{W}}
\item{basis vectors}{the columns of first matrix factor \eqn{W}}
\item{mixture matrix}{the second matrix factor \eqn{H}} \item{mixtures
coefficients}{the columns of second matrix factor \eqn{H}}
}

However, because the package NMF was primarily implemented to work with gene
expression microarray data, it also provides a layer to easily and
intuitively work with objects from the Bioconductor base framework.
See \link{bioc-NMF} for more details.
}
\section{Slots}{

\describe{
\item{\code{W}}{A \code{matrix} that contains the basis matrix, i.e. the \emph{first}
matrix factor of the factorisation}

\item{\code{H}}{A \code{matrix} that contains the coefficient matrix, i.e. the
\emph{second} matrix factor of the factorisation}

\item{\code{bterms}}{a \code{data.frame} that contains the primary data that
define fixed basis terms. See \code{\link{bterms}}.}

\item{\code{ibterms}}{integer vector that contains the indexes of the basis components
that are fixed, i.e. for which only the coefficient are estimated.

IMPORTANT: This slot is set on construction of an NMF model via
\code{\link[=nmfModel,formula,ANY-method]{nmfModel}} and is not recommended to
not be subsequently changed by the end-user.}

\item{\code{cterms}}{a \code{data.frame} that contains the primary data that
define fixed coefficient terms. See \code{\link{cterms}}.}

\item{\code{icterms}}{integer vector that contains the indexes of the basis components
that have fixed coefficients, i.e. for which only the basis vectors are estimated.

IMPORTANT: This slot is set on construction of an NMF model via
\code{\link[=nmfModel,formula,ANY-method]{nmfModel}} and is not recommended to
not be subsequently changed by the end-user.}
}}

\examples{
# create a completely empty NMFstd object
new('NMFstd')

# create a NMF object based on one random matrix: the missing matrix is deduced
# Note this only works when using factory method NMF 
n <- 50; r <- 3; 
w <- rmatrix(n, r) 
nmfModel(W=w)

# create a NMF object based on random (compatible) matrices
p <- 20
h <- rmatrix(r, p)
nmfModel(W=w, H=h)

# create a NMF object based on incompatible matrices: generate an error
h <- rmatrix(r+1, p)
try( new('NMFstd', W=w, H=h) )
try( nmfModel(w, h) )

# Giving target dimensions to the factory method allow for coping with dimension
# incompatibilty (a warning is thrown in such case) 
nmfModel(r, W=w, H=h)
 
# create a NMF array object based on random (compatible) arrays
# extra dimension (levels)
q <- 2 
w <- array(seq(n*r*q), dim = c(n, r, q))
h <- rmatrix(r, p)
nmfModel(W = w, H = h)

# random standard NMF model
x <- rnmf(3, 10, 5)
basis(x)
coef(x)

# set matrix factors
basis(x) <- matrix(1, nrow(x), nbasis(x))
coef(x) <- matrix(1, nbasis(x), ncol(x))
# set random factors
basis(x) <- rmatrix(basis(x))
coef(x) <- rmatrix(coef(x))

# incompatible matrices generate an error:
try( coef(x) <- matrix(1, nbasis(x)-1, nrow(x)) )
# but the low-level method allow it
.coef(x) <- matrix(1, nbasis(x)-1, nrow(x))
try( validObject(x) )

# random standard NMF model
x <- rnmf(3, 10, 5)
all.equal(fitted(x), basis(x) \%*\% coef(x))


}
\references{
Lee DD, Seung H (2001). “Algorithms for non-negative matrix factorization.” _Advances in neural information processing systems_. <URL:
http://scholar.google.com/scholar?q=intitle:Algorithms+for+non-negative+matrix+factorization\#0>.
}
\seealso{
Other NMF-model: 
\code{\link{NMFOffset-class}},
\code{\link{NMFns-class}}
}
\concept{NMF-model}
\section{Methods (by generic)}{
\bold{.basis:}

\itemize{
\item \code{.basis(object = NMFstd)}: Get the basis matrix in standard NMF models

This function returns slot \code{W} of \code{object}.
}


\bold{.basis<-:}

\itemize{
\item \code{.basis<-(object = NMFstd,value = array)}: Set the basis matrix in standard NMF models

This function sets slot \code{W} of \code{object}.

\item \code{.basis<-(object = NMFstd,value = mMatrix)}: Replaces a slice of the basis array.
}


\bold{.coef:}

\itemize{
\item \code{.coef(object = NMFstd)}: Get the mixture coefficient matrix in standard NMF models, which
is stored in slot \code{H} of \code{object}.
}


\bold{.coef<-:}

\itemize{
\item \code{.coef<-(object = NMFstd,value = array)}: Set the mixture coefficient matrix in standard NMF models

This function sets slot \code{H} of \code{object}.

\item \code{.coef<-(object = NMFstd,value = mMatrix)}: Replaces a slice of the coefficent array.
}


\bold{bterms<-:}

\itemize{
\item \code{bterms<-(object = NMFstd)}: Default method tries to coerce \code{value} into a \code{data.frame} with
\code{\link{as.data.frame}}.
}


\bold{cterms<-:}

\itemize{
\item \code{cterms<-(object = NMFstd)}: Default method tries to coerce \code{value} into a \code{data.frame} with
\code{\link{as.data.frame}}.
}


\bold{fitted:}

\itemize{
\item \code{fitted(object = NMFstd)}: Compute the target matrix estimate in \emph{standard NMF models}.

The estimate matrix is computed as the product of the two matrix slots
\code{W} and \code{H}:
\deqn{\hat{V} = W H}{V ~ W H}
}


\bold{ibterms:}

\itemize{
\item \code{ibterms(object = NMFstd)}: Method for standard NMF models, which returns the integer vector that is
stored in slot \code{ibterms} when a formula-based NMF model is instantiated.
}


\bold{icterms:}

\itemize{
\item \code{icterms(object = NMFstd)}: Method for standard NMF models, which returns the integer vector that is
stored in slot \code{icterms} when a formula-based NMF model is instantiated.
}


\bold{t:}

\itemize{
\item \code{t(NMFstd)}: transposes an NMF standard model object, including fixed terms.
}

}

