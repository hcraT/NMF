% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NMFStrategy-class.R, R/registry-algorithms.R,
%   R/nmf.R
\docType{class}
\name{NMFStrategy-class}
\alias{NMFStrategy-class}
\alias{show,NMFStrategy-method}
\alias{NMFStrategy,character,NMFStrategy-method}
\alias{NMFStrategy,NMFStrategy,missing-method}
\alias{NMFStrategy,NULL,NMFStrategy-method}
\alias{deviance,NMFStrategy-method}
\alias{objective,NMFStrategy-method}
\alias{objective<-,NMFStrategy,character-method}
\alias{objective<-,NMFStrategy,function-method}
\alias{modelname,NMFStrategy-method}
\alias{is.mixed}
\alias{canFit,NMFStrategy,character-method}
\alias{nmf,mMatrix,numeric,NMFStrategy-method}
\title{Virtual Interface for NMF Algorithms}
\usage{
\S4method{show}{NMFStrategy}(object)

\S4method{NMFStrategy}{character,NMFStrategy}(name, method, ...)

\S4method{NMFStrategy}{NMFStrategy,missing}(name, method, ...)

\S4method{NMFStrategy}{`NULL`,NMFStrategy}(name, method, ...)

\S4method{deviance}{NMFStrategy}(object, x, y, ...)

\S4method{objective}{NMFStrategy}(object)

\S4method{objective}{NMFStrategy,character}(object) <- value

\S4method{objective}{NMFStrategy,`function`}(object) <- value

\S4method{modelname}{NMFStrategy}(object)

is.mixed(object)

\S4method{canFit}{NMFStrategy,character}(x, y, exact = FALSE)

\S4method{nmf}{mMatrix,numeric,NMFStrategy}(
  x,
  rank,
  method,
  seed = nmf.getOption("default.seed"),
  rng = NULL,
  nrun = if (length(rank) > 1L) 30 else 1,
  model = NULL,
  .options = list(),
  .pbackend = nmf.getOption("pbackend"),
  .callback = NULL,
  .tmpdir = getwd(),
  ...
)
}
\arguments{
\item{x}{an NMF model that estimates \code{y}.}

\item{exact}{for logical that indicates if an algorithm is considered able to fit
only the models that it explicitly declares (\code{TRUE}), or if it should be
considered able to also fit models that extend models that it explicitly fits.}

\item{seed}{specification of the starting point or seeding method, which will
compute a starting point, usually using data from the target matrix in order to
provide a good guess.

The seeding method may be specified in the following way:

\describe{

\item{a \code{character} string:}{ giving the name of a \emph{registered}
seeding method. The corresponding method will be called to compute
the starting point.

Available methods can be listed via \code{nmfSeed()}.
See its dedicated documentation for details on each available registered methods
(\code{\link{nmfSeed}}).
}

\item{a \code{list}:}{ giving the name of a \emph{registered}
seeding method and, optionally, extra parameters to pass to it.}

\item{a single \code{numeric}:}{ that is used to seed the random number
generator, before generating a random starting point.

Note that when performing multiple runs, the L'Ecuyer's RNG is used in order to
produce a sequence of random streams, that is used in way that ensures
that parallel computation are fully reproducible.
}

\item{an object that inherits from \code{\linkS4class{NMF}}:}{ it should
contain the    data of an initialised NMF model, i.e. it must contain valid
basis and mixture coefficient matrices, directly usable by the algorithm's
workhorse function.}

\item{a \code{function}:}{ that computes the starting point. It must have
signature \code{(object="NMF", target="matrix", ...)} and return an object that
inherits from class \code{NMF}.
It is recommended to use argument \code{object} as a template for the returned object,
by only updating the basis and coefficient matrices, using \code{\link{basis<-}} and
\code{\link{coef<-}} respectively.
}

}}

\item{rng}{rng specification for the run(s).
This argument should be used to set the the RNG seed, while still specifying the seeding
method argument \var{seed}.}

\item{nrun}{number of runs to perform.
It specifies the number of runs to perform.
By default only one run is performed, except if \code{rank} is a numeric vector
with more than one element, in which case a default of 30 runs per value of the
rank are performed, allowing the computation of a consensus matrix that is used
in selecting the appropriate rank (see \code{\link{consensus}}).

When using a random seeding method, multiple runs are generally required to
achieve stability and avoid \emph{bad} local minima.}

\item{model}{specification of the type of NMF model to use.

It is used to instantiate the object that inherits from class \code{\linkS4class{NMF}},
that will be passed to the seeding method.
The following values are supported:
\itemize{

\item \code{NULL}, the default model associated to the NMF algorithm is
instantiated and \code{...} is looked-up for arguments with names that
correspond to slots in the model class, which are passed to the function
\code{\link{nmfModel}} to instantiate the model.
Arguments in \code{...} that do not correspond to slots are passed to the
algorithm.

\item a single \code{character} string, that is the name of the NMF model
class to be instantiate.
In this case, arguments in \code{...} are handled in the same way as
when \code{model} is \code{NULL}.

\item a \code{list} that contains named values that are passed to the
function \code{\link{nmfModel}} to instantiate the model.
In this case, \code{...} is not looked-up at all, and passed entirely to
the algorithm.
This means that all necessary model parameters must be specified in
\code{model}.

}

\strong{Argument/slot conflicts:}
In the case a parameter of the algorithm has the same name as a model slot,
then \code{model} MUST be a list -- possibly empty --, if one wants this
parameter to be effectively passed to the algorithm.

If a variable appears in both arguments \code{model} and \code{\dots},
the former will be used to initialise the NMF model, the latter will be
passed to the NMF algorithm.
See code examples for an illustration of this situation.}

\item{.options}{this argument is used to set runtime options.

It can be a \code{list} containing named options with their values, or, in
the case only boolean/integer options need to be set, a character string
that specifies which options are turned on/off or their value, in a unix-like
command line argument way.

The string must be composed of characters that correspond to a given option
(see mapping below), and modifiers '+' and '-' that toggle options on and off respectively.
E.g. \code{.options='tv'} will toggle on options \code{track} and \code{verbose},
while \code{.options='t-v'} will toggle on option \code{track} and toggle off
option \code{verbose}.

Modifiers '+' and '-' apply to all option character found after them:
\code{t-vp+k} means \code{track=TRUE}, \code{verbose=parallel=FALSE},
and \code{keep.all=TRUE}.
The default behaviour is to assume that \code{.options} starts with a '+'.

for options that accept integer values, the value may be appended to the
option's character e.g. \code{'p4'} for asking for 4 processors or \code{'v3'}
for showing verbosity message up to level 3.

The following options are available (the characters after \dQuote{-} are those
to use to encode \code{.options} as a string):
\describe{

\item{debug - d}{ Toggle debug mode (default: \code{FALSE}).
Like option \code{verbose} but with more information displayed.}

\item{keep.all - k}{ used when performing multiple runs (\code{nrun}>1): if
\code{TRUE}, all factorizations are saved and returned (default: \code{FALSE}).
Otherwise only the factorization achieving the minimum residuals is returned.}

\item{parallel - p}{ this option is useful on multicore *nix or Mac machine
only, when performing multiple runs (\code{nrun} > 1) (default: \code{TRUE}).
If \code{TRUE}, the runs are performed using the parallel foreach backend
defined in argument \code{.pbackend}.
If this is set to \code{'mc'} or \code{'par'} then \code{nmf} tries to
perform the runs using multiple cores with package
\code{link[doParallel]{doParallel}} -- which therefore needs to be installed.

If equal to an integer, then \code{nmf} tries to perform the computation on
the specified number of processors.
When passing options as a string the number is appended to the option's character
e.g. \code{'p4'} for asking for 4 processors.

If \code{FALSE}, then the computation is performed sequentially using the base
function \code{\link{sapply}}.

Unlike option 'P' (capital 'P'), if the computation cannot be performed in
parallel, then it will still be carried on sequentially.

\strong{IMPORTANT NOTE FOR MAC OS X USERS:} The parallel computation is
based on the \code{doMC} and \code{multicore} packages, so the same care
should be taken as stated in the vignette of \code{doMC}: \emph{\dQuote{it
is not safe to use doMC from R.app on Mac OS X. Instead, you should use doMC
from a terminal session, starting R from the command line.}} }

\item{parallel.required - P}{ Same as \code{p}, but an error is thrown if
the computation cannot be performed in parallel or with the specified number
of processors.}

\item{shared.memory - m}{ toggle usage of shared memory (requires the
\pkg{synchronicity} package).
Default is as defined by \code{nmf.getOption('shared.memory')}.}

\item{restore.seed - r}{ deprecated option since version 0.5.99.
Will throw a warning if used.}

\item{simplifyCB - S}{ toggle simplification of the callback results.
Default is \code{TRUE}}

\item{track - t}{ enables error tracking (default: FALSE).
If \code{TRUE}, the returned object's slot \code{residuals} contains the
trajectory of the objective values, which can be retrieved via
\code{residuals(res, track=TRUE)}
This tracking functionality is available for all built-in algorithms.
}

\item{verbose - v}{ Toggle verbosity (default: \code{FALSE}).
If \code{TRUE}, messages about the configuration and the state of the
current run(s) are displayed.
The level of verbosity may be specified with an integer value, the greater
the level the more messages are displayed.
Value \code{FALSE} means no messages are displayed, while value \code{TRUE}
is equivalent to verbosity level 1.
}

}}

\item{.pbackend}{specification of the \code{\link{foreach}} parallel backend
to register and/or use when running in parallel mode.
See options \code{p} and \code{P} in argument \code{.options} for how to
enable this mode.
Note that any backend that is internally registered is cleaned-up on exit,
so that the calling foreach environment should not be affected by a call to
\code{nmf} -- except when \code{.pbackend=NULL}.

Currently it accepts the following values:
\describe{

\item{\sQuote{par}}{ use the backend(s) defined by the package
\code{\link{doParallel}};}
\item{a numeric value}{ use the specified number of cores with \code{doParallel}
backend;}
\item{\sQuote{seq}}{ use the foreach sequential backend \code{doSEQ};}
\item{\code{NULL}}{ use currently registered backend;}
\item{\code{NA}}{ do not compute using a foreach loop -- and therefore not in
parallel --  but rather use a call to standard \code{\link{sapply}}.
This is useful for when developing/debugging NMF algorithms, as foreach loop
handling may sometime get in the way.

Note that this is equivalent to using \code{.options='-p'} or \code{.options='p0'},
but takes precedence over any option specified in \code{.options}:
e.g. \code{nmf(..., .options='P10', .pbackend=NA)} performs all runs sequentially
using \code{sapply}.
Use \code{nmf.options(pbackend=NA)} to completely disable foreach/parallel computations
for all subsequent \code{nmf} calls.}

\item{\sQuote{mc}}{ identical to \sQuote{par} and defined to ensure backward
compatibility.}
}}

\item{.callback}{Used when option \code{keep.all=FALSE} (default).  It
allows to pass a callback function that is called after each run when
performing multiple runs (i.e. with \code{nrun>1}).
This is useful for example if one is also interested in saving summary
measures or process the result of each NMF fit before it gets discarded.
After each run, the callback function is called with two arguments, the
\code{\linkS4class{NMFfit}} object that as just been fitted and the run
number: \code{.callback(res, i)}.
For convenience, a function that takes only one argument or has
signature \code{(x, ...)} can still be passed in \code{.callback}.
It is wrapped internally into a dummy function with two arguments,
only the first of which is passed to the actual callback function (see example
with \code{summary}).

The call is wrapped into a tryCatch so that callback errors do not stop the
whole computation (see below).

The results of the different calls to the callback function are stored in a
miscellaneous slot accessible using the method \code{$} for \code{NMFfit}
objects: \code{res$.callback}.
By default \code{nmf} tries to simplify the list of callback result using
\code{sapply}, unless option \code{'simplifyCB'} is \code{FASE}.

If no error occurs \code{res$.callback} contains the list of values that
resulted from the calling the callback function --, ordered as the fits.
If any error occurs in one of the callback calls, then the whole computation is
\strong{not} stopped, but the error message is stored in \code{res$.callback},
in place of the result.

See the examples for sample code.}

\item{.tmpdir}{path to the directory where a temporary directory is created to
store intermediate results. This is only relevant for multi-runs performed using
a foreach backend (including the sequential backend \code{'doSEQ'}).}
}
\value{
The returned value depends on the run mode:

\item{Single run:}{An object of class \code{\linkS4class{NMFfit}}.}

\item{Multiple runs, single method:}{When \code{nrun > 1} and \code{method}
is not \code{list}, this method returns an object of class \code{\linkS4class{NMFfitX}}.}

\item{Multiple runs, multiple methods:}{When \code{nrun > 1} and \code{method}
is a \code{list}, this method returns an object of class \code{\linkS4class{NMFList}}.}
}
\description{
This class partially implements the generic interface defined for general
algorithms defined in the \pkg{NMF} package (see \code{\link{algorithmic-NMF}}).
}
\section{Slots}{

\describe{
\item{\code{objective}}{the objective function associated with the algorithm (Frobenius, Kullback-Leibler, etc...).
It is either an access key of a registered objective function or a function definition.
In the latter case, the given function must have the following signature \code{(x="NMF", y="matrix")}
and return a nonnegative real value.}

\item{\code{model}}{a character string giving either the (sub)class name of the NMF-class instance used
and returned by the strategy, or a function name.}

\item{\code{mixed}}{a logical that indicates if the algorithm works on mixed-sign data.}
}}

\examples{
# get the type of model(s) associated with an NMF algorithm
modelname( nmfAlgorithm('brunet') )
modelname( nmfAlgorithm('nsNMF') )
modelname( nmfAlgorithm('offset') )

}
\keyword{internal}
\section{Methods (by generic)}{
\bold{canFit:}

\itemize{
\item \code{canFit(x = NMFStrategy,y = NMF)}: Tells if an NMF algorithm can fit the same class of models as \code{y}

\item \code{canFit(x = NMFStrategy,y = character)}: Tells if an NMF algorithm can fit a given class of NMF models
}


\bold{deviance:}

\itemize{
\item \code{deviance(object = NMFStrategy)}: Computes the value of the objective function between the estimate \code{x}
and the target \code{y}, using the objective function associated with the given
\code{NMFStrategy} object.
}


\bold{modelname:}

\itemize{
\item \code{modelname(object = NMFStrategy)}: Returns the model(s) that an NMF algorithm can fit.
}


\bold{nmfFormals:}

\itemize{
\item \code{nmfFormals(NMFStrategy)}: Returns the extra arguments that can be passed to an algorithm encapsulated in an \code{NMFStrategy} object.

Arguments that have default values defined by the strategy are set accordingly.
}


\bold{NMFStrategy:}

\itemize{
\item \code{NMFStrategy(name = character,method = NMFStrategy)}: Creates an \code{NMFStrategy} object based on a template object (Constructor-Copy).

\item \code{NMFStrategy(name = NMFStrategy,method = missing)}: Creates an \code{NMFStrategy} based on a template object (Constructor-Copy),
in particular it uses the \strong{same} name.

\item \code{NMFStrategy(name = NULL,method = NMFStrategy)}: Creates an \code{NMFStrategy} based on a template object (Constructor-Copy)
but using a randomly generated name.
}


\bold{objective:}

\itemize{
\item \code{objective(object = NMFStrategy)}: Gets the objective function associated with an NMF algorithm.

It is used in \code{\link[=deviance,NMFStrategy-method]{deviance}}
to compute the objective value for an NMF model with respect to
a given target matrix.
}


\bold{objective<-:}

\itemize{
\item \code{objective<-(object = NMFStrategy,value = character)}: Sets the objective function associated with an NMF algorithm, with a character string
that must be a registered objective function.

\item \code{objective<-(object = NMFStrategy,value = function)}: Sets the objective function associated with an NMF algorithm, with a function
that computes the approximation error between an NMF model and a target matrix.
}


\bold{run:}

\itemize{
\item \code{run(object = NMFStrategy,y = mMatrix,x = NMFfit)}: Pure virtual method defined for all NMF algorithms to ensure
that a method \code{run} is defined by sub-classes of \code{NMFStrategy}.

It throws an error if called directly.

\item \code{run(object = NMFStrategy,y = mMatrix,x = NMF)}: Method to run an NMF algorithm directly starting from a given NMF model.
}

}


\section{Functions}{
\itemize{
\item \code{is.mixed}: \code{is.mixed} tells if an NMF algorithm works on mixed-sign data.
}}

